<!DOCTYPE html>
<html>
<head>
<title>Nerd Ass Game (Chess)</title>
<style>
  body {
    font-family: sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .container {
    border: 4px solid #333; /* Leader border */
    padding: 20px;
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .board {
    display: grid;
    grid-template-columns: repeat(8, 50px);
    grid-template-rows: repeat(8, 50px);
    border: 2px solid #000;
  }

  .square {
    width: 50px;
    height: 50px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
  }

  .white {
    background-color: #f0d9b5;
  }

  .black {
    background-color: #b58863;
  }

  .piece {
    cursor: grab;
  }

  .controls {
    margin-top: 20px;
    display: flex;
    gap: 20px;
    align-items: center;
  }

  #timer {
    font-size: 1.2em;
  }
</style>
</head>
<body>
  <div class="container">
    <h1>Nigger Chess</h1>

    <div class="controls">
      <div>
        <label for="gameMode">Game Mode:</label>
        <select id="gameMode">
          <option value="twoPlayer">Two Player</option>
          <option value="ai">Play with AI</option>
        </select>
      </div>
      <div id="playerTurn">Turn: White</div>
      <div id="timer">Time: 00:00</div>
      <button id="resetButton">Reset Game</button>
    </div>

    <div class="board" id="chessBoard">
      </div>
  </div>

  <script>
    const boardElement = document.getElementById('chessBoard');
    const playerTurnElement = document.getElementById('playerTurn');
    const timerElement = document.getElementById('timer');
    const resetButton = document.getElementById('resetButton');
    const gameModeSelect = document.getElementById('gameMode');

    let board = [
      ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
      ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['', '', '', '', '', '', '', ''],
      ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
      ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
    ];

    let currentPlayer = 'white';
    let selectedPiece = null;
    let possibleMoves = [];
    let timerInterval;
    let startTime;

    function generateBoard() {
      boardElement.innerHTML = '';
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          const square = document.createElement('div');
          square.classList.add('square');
          if ((i + j) % 2 === 0) {
            square.classList.add('white');
          } else {
            square.classList.add('black');
          }
          square.dataset.row = i;
          square.dataset.col = j;

          const piece = board[i][j];
          if (piece) {
            const pieceElement = document.createElement('div');
            pieceElement.classList.add('piece');
            pieceElement.textContent = getPieceUnicode(piece);
            pieceElement.dataset.piece = piece;
            square.appendChild(pieceElement);

            pieceElement.addEventListener('mousedown', selectPiece);
          }

          square.addEventListener('mouseup', movePiece);
          boardElement.appendChild(square);
        }
      }
    }

    function getPieceUnicode(piece) {
      switch (piece) {
        case 'r': return '♖';
        case 'n': return '♘';
        case 'b': return '♗';
        case 'q': return '♕';
        case 'k': return '♔';
        case 'p': return '♟';
        case 'R': return '♜';
        case 'N': return '♞';
        case 'B': return '♝';
        case 'Q': return '♛';
        case 'K': return '♚';
        case 'P': return '♟';
        default: return '';
      }
    }

    function selectPiece(event) {
      if (gameModeSelect.value === 'ai' && currentPlayer === 'black') {
        return; // AI's turn
      }

      const pieceElement = event.target;
      const piece = pieceElement.dataset.piece;
      const row = parseInt(pieceElement.parentNode.dataset.row);
      const col = parseInt(pieceElement.parentNode.dataset.col);

      if ((currentPlayer === 'white' && piece === piece.toUpperCase()) ||
          (currentPlayer === 'black' && piece === piece.toLowerCase())) {
        selectedPiece = { element: pieceElement, row, col, piece };
        highlightPossibleMoves(row, col, piece);
      } else {
        selectedPiece = null;
        removeHighlight();
      }
    }

    function highlightPossibleMoves(row, col, piece) {
      removeHighlight();
      possibleMoves = getPossibleMoves(row, col, piece);
      possibleMoves.forEach(move => {
        const square = boardElement.children[move.row * 8 + move.col];
        square.classList.add('possible-move');
      });
    }

    function removeHighlight() {
      const highlighted = document.querySelectorAll('.possible-move');
      highlighted.forEach(square => square.classList.remove('possible-move'));
      possibleMoves = [];
    }

    function movePiece(event) {
      if (!selectedPiece) return;

      const targetSquare = event.target.closest('.square');
      if (!targetSquare) return;

      const targetRow = parseInt(targetSquare.dataset.row);
      const targetCol = parseInt(targetSquare.dataset.col);

      const isValidMove = possibleMoves.some(move => move.row === targetRow && move.col === targetCol);

      if (isValidMove) {
        board[targetRow][targetCol] = selectedPiece.piece;
        board[selectedPiece.row][selectedPiece.col] = '';
        generateBoard();
        switchPlayer();
        removeHighlight();
        selectedPiece = null;

        if (gameModeSelect.value === 'ai' && currentPlayer === 'black') {
          setTimeout(makeAiMove, 500); // Simple delay for AI move
        }
      } else if (event.target.classList.contains('piece') && event.target.parentNode === targetSquare) {
        // If clicked on another piece, select it
        selectPiece(event);
      } else {
        removeHighlight();
        selectedPiece = null;
      }
    }

    function getPossibleMoves(row, col, piece) {
      const moves = [];
      const isWhite = piece === piece.toUpperCase();
      const direction = isWhite ? -1 : 1;

      switch (piece.toLowerCase()) {
        case 'p': // Pawn
          const startRow = isWhite ? 6 : 1;
          const enPassantRow = isWhite ? 3 : 4;
          const enPassantDirection = [[0, -1], [0, 1]];

          // Forward movement
          if (board[row + direction]?.[col] === '') {
            moves.push({ row: row + direction, col });
            if (row === startRow && board[row + 2 * direction]?.[col] === '') {
              moves.push({ row: row + 2 * direction, col });
            }
          }

          // Capture diagonally
          if (board[row + direction]?.[col + 1] && isOpponent(piece, board[row + direction][col + 1])) {
            moves.push({ row: row + direction, col: col + 1 });
          }
          if (board[row + direction]?.[col - 1] && isOpponent(piece, board[row + direction][col - 1])) {
            moves.push({ row: row + direction, col: col - 1 });
          }
          break;

        case 'r': // Rook
          const rookDirections = [[0, 1], [0, -1], [1, 0], [-1, 0]];
          for (const [dr, dc] of rookDirections) {
            for (let i = 1; ; i++) {
              const newRow = row + dr * i;
              const newCol = col + dc * i;
              if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
              moves.push({ row: newRow, col: newCol });
              if (board[newRow][newCol] !== '') {
                if (isOpponent(piece, board[newRow][newCol])) {
                  break; // Can capture, but cannot move further
                } else {
                  break; // Own piece, cannot move further
                }
              }
            }
          }
          break;

        case 'n': // Knight
          const knightMoves = [[-2, -1], [-2, 1], [-1, -2], [-1, 2], [1, -2], [1, 2], [2, -1], [2, 1]];
          for (const [dr, dc] of knightMoves) {
            const newRow = row + dr;
            const newCol = col + dc;
            if (newRow >= 0 && newRow <= 7 && newCol >= 0 && newCol <= 7 &&
                (board[newRow][newCol] === '' || isOpponent(piece, board[newRow][newCol]))) {
              moves.push({ row: newRow, col: newCol });
            }
          }
          break;

        case 'b': // Bishop
          const bishopDirections = [[1, 1], [1, -1], [-1, 1], [-1, -1]];
          for (const [dr, dc] of bishopDirections) {
            for (let i = 1; ; i++) {
              const newRow = row + dr * i;
              const newCol = col + dc * i;
              if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
              moves.push({ row: newRow, col: newCol });
              if (board[newRow][newCol] !== '') {
                if (isOpponent(piece, board[newRow][newCol])) {
                  break; // Can capture, but cannot move further
                } else {
                  break; // Own piece, cannot move further
                }
              }
            }
          }
          break;

        case 'q': // Queen (Rook + Bishop moves)
          const queenDirections = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
          for (const [dr, dc] of queenDirections) {
            for (let i = 1; ; i++) {
              const newRow = row + dr * i;
              const newCol = col + dc * i;
              if (newRow < 0 || newRow > 7 || newCol < 0 || newCol > 7) break;
              moves.push({ row: newRow, col: newCol });
              if (board[newRow][newCol] !== '') {
                if (isOpponent(piece, board[newRow][newCol])) {
                  break; // Can capture, but cannot move further
                } else {
                  break; // Own piece, cannot move further
                }
              }
            }
          }
          break;

        case 'k': // King
          const kingMoves = [[0, 1], [0, -1], [1, 0], [-1, 0], [1, 1], [1, -1], [-1, 1], [-1, -1]];
          for (const [dr, dc] of kingMoves) {
            const newRow = row + dr;
            const newCol = col + dc;
            if (newRow >= 0 && newRow <= 7 && newCol >= 0 && newCol <= 7 &&
                (board[newRow][newCol] === '' || isOpponent(piece, board[newRow][newCol]))) {
              moves.push({ row: newRow, col: newCol });
            }
          }
          break;
      }
      return moves;
    }

    function isOpponent(piece1, piece2) {
      const isWhite1 = piece1 === piece1.toUpperCase();
      const isWhite2 = piece2 === piece2.toUpperCase();
      return isWhite1 !== isWhite2;
    }

    function switchPlayer() {
      currentPlayer = currentPlayer === 'white' ? 'black' : 'white';
      playerTurnElement.textContent = `Turn: ${currentPlayer.charAt(0).toUpperCase() + currentPlayer.slice(1)}`;
    }

    function startTimer() {
      startTime = Date.now();
      timerInterval = setInterval(() => {
        const elapsedTime = Math.floor((Date.now() - startTime) / 1000);
        const minutes = Math.floor(elapsedTime / 60).toString().padStart(2, '0');
        const seconds = (elapsedTime % 60).toString().padStart(2, '0');
        timerElement.textContent = `Time: ${minutes}:${seconds}`;
      }, 1000);
    }

    function stopTimer() {
      clearInterval(timerInterval);
    }

    function resetGame() {
      board = [
        ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
        ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['', '', '', '', '', '', '', ''],
        ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
        ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
      ];
      currentPlayer = 'white';
      selectedPiece = null;
      possibleMoves = [];
      stopTimer();
      timerElement.textContent = 'Time: 00:00';
      startTimer();
      playerTurnElement.textContent = 'Turn: White';
      generateBoard();
    }

    function makeAiMove() {
      // Very basic AI: Find a random valid move for black
      const blackPieces = [];
      for (let i = 0; i < 8; i++) {
        for (let j = 0; j < 8; j++) {
          if (board[i][j] && board[i][j] === board[i][j].toLowerCase()) {
            blackPieces.push({ row: i, col: j, piece: board[i][j] });
          }
        }
      }

      if (blackPieces.length > 0) {
        const randomPiece = blackPieces[Math.floor(Math.random() * blackPieces.length)];
        const possibleAiMoves = getPossibleMoves(randomPiece.row, randomPiece.col, randomPiece.piece);

        if (possibleAiMoves.length > 0) {
          const randomMove = possibleAiMoves[Math.floor(Math.random() * possibleAiMoves.length)];
          board[randomMove.row][randomMove.col] = randomPiece.piece;
          board[randomPiece.row][randomPiece.col] = '';
          generateBoard();
          switchPlayer();
        }
      }
    }

    resetButton.addEventListener('click', resetGame);
    gameModeSelect.addEventListener('change', resetGame); // Reset when game mode changes

    startTimer();
    generateBoard();
  </script>
</body>
</html>
